1.继承：把多个类的公共属性和方法抽取出来组成一个类A，然后让其他类B间接拥有类A的公共属性和方法。

  继承的特点：减少代码量，提高代码的复用率，便于后期维护，提高子类的扩展能力

  实现：A extends B()

  注意：私有元素，构造方法不能被继承，静态方法（static）可以被继承，不能被重写

  方法重写（override）：发生在继承前提下，子类对父类方法的重新实现，
	  除了重新更改以外，访问权限修饰符变大或不变，其余坚决不能发生变化，要保持和父类实现方法的声明一样

关键字：super，发生在继承之后用来指代父类所用；可以访问父类的属性和方法，也可以访问父类的构造方法时且必须出现
在构造方法的第一行。

注意问题：不能同时出现super()和this()访问
	继承的本质是在子类构造方法的第一行访问了父类的构造方法，因此在创建子类对象之前访问了父类的构造方法，
	生成了一个父类对象去调用父类方法因机制问题，this()中肯定也有super()去执行上述步骤，故new一个子类对象
	调用两次父类构造方法肯定会报错。
	
2.final 关键字：可以修饰类（此类不能被继承，不能被定义成抽象类，接口），属性（此时该变量变成了常量），
				方法（此方法不能被重写，不能被定义成抽象方法）
	在一个类中，用final和static同时修饰某个属性，则必须在属性区赋值，因为static修饰的在生成对象时优先执行，
	然后调用构造方法，若不在属性区赋值而在构造方法中赋值，就违背了final的语法原则
	（就相当于在属性区给其赋个NULL，而在构造方法中改变其值，显然是错误的）
	
3.抽象类：不能实例化对象的类（使用abstract关键字修饰一个普通的类）
  意义：被继承
  抽象类所定义的标准称作抽象方法：访问权限修饰符  abstract 返回值类型 方法名（参数列表）
  注意：抽象类中不一定存在抽象方法，可以存在普通方法，必须有构造方法，有抽象方法的一定是抽象类
 
4.接口：特殊的抽象类
  意义：解决java中的单继承，实现一个类中可以聚集有多个类的功能
  public interface 接口名{}
  接口中的元素：static修饰的变量
				jdk1.7之前只能存在抽象方法，jdk1.8可以存在有静态的方法
5.多态：对外一种表现，对内多种实现
		继承，方法的重写，多态参数（父类引用指向子类的对象）

6.instanceof 关键字：判断两个类型是否一致
	boolean b=a instanceof b;
	
