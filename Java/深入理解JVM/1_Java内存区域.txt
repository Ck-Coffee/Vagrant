一运行时数据区域
	1.程序计数器(PC)：
		存储下一条字节码指令，线程私有，不会发生OOM,主要用于分支，循环，跳转，异常处理，线程恢复

	2.虚拟机栈(Java Virtual Machine Stack)：
		线程私有，描述Java方法运行时的内存模型，栈帧(方法运行时的数据结构)，用于存储局部表量表，操作数栈，动态链接
			方法出口。会发生StackOverFlow(调用太深)和OOM异常(内存不足)。
	3.本地方法栈(Native Method Stack)：
		线程私有，与虚拟机栈类似，只不过是为Native方法提供服务，同样会发生StackOverFlow和OOM异常。
	4.Java堆(Java Heap)：
		线程共享，存放对象实例，目前对象不一定分配在堆上(JIT和逃逸分析)，可分为新生代和老年代，会发生OOM(内存已满，且无法扩展)。
	5.方法区(Non-Heap)：
		线程共享，存放加载的类信息，常量，静态变量，即时编译后的代码，会发生OOM(内存不足)。
		
		a).运行时常量池：属于方法区，存放字面量和符号引用(用符号描述所引用的目标)，具有动态性，会发生OOM(申请不到内存)。
	
	*直接内存(Direct Memory)：不属于运行时内存，用于NIO（一种基于通道与缓冲区的I/O方式），使用Native方法在堆外分配空间，然后使用DirectByteBuffer对象
			来对这块内存进行操作避免在Java堆和Native堆中来回复制数据。也会发生OOM

二.对象探秘
	1.对象的创建：
		a).指针碰撞：将Java堆分为两块区域，假设内存规整，将使用过的内存放在一边，空闲的内存放在另一边，中间用指针隔开，分配对象时，就将指针往空闲的一端移动
			与对象大小相等的距离。
		问题：在并发情况下，不安全。采用CAS配上失败重试来保证原子性。
		b).空闲列表：虚拟机维护一张表，上面记录了哪些内存是可用的，当分配内存时，从列表上找一块足够大的空间划分给对象，然后更新列表
		c).本地线程分配缓冲(TLAB):分配内存时，先在TLAB上分配，只有TLAB内存用完分配新的TLAB时，才需要同步锁定。
		d).栈上分配：这里涉及逃逸分析，就是当一个对象只会在该方法中使用的话，就可以不用再堆上分配，而直接在栈上分配。
			具体细节后面补充。
	2.对象的组成：
		a).对象头：
			*运行时数据： 包括类的元数据信息，对象的哈希码，对象的GC分代年龄，锁状态标志，偏向时间戳，偏向线程ID还有
			  偏向锁等的设置
			*类型指针：对象指向它的类元数据的指针(假如对象是数组，那么还有一个记录长度的数据)
		b).实例数据:对象真正存储的有效信息
		c).对象填充：保证对象的大小是8字节的整数倍，不绝对存在。
	3.对象的访问定位：
		a).使用句柄：reference中存放的是句柄地址，句柄(堆内)中有两个指针，类型指针指向方法区的对象类型信息，
			实例指针指向堆中的实例数据。
		b).直接指针：reference中存放的是对象地址，对象里的指针包含指向方法区中的对象类型数据。
		
		对比：reference存放的是句柄，比较稳定，在对象移动时，只需要更改句柄中的指针，不用修改reference;
			当使用直接指针时，由于减少了一次指针定位的开销，所以访问的效率会提高。
三.各种异常及实际场景
	OutOfMemoryError异常 StackOverFlow异常
		a).堆溢出 -> 不断的新建对象
			还要分析是内存溢出，还是内存泄漏，再去具体的分析
		b).栈溢出 -> 递归调用方法(无论栈帧过大，还是虚拟机栈容量太小都是抛StackOverFlow异常)，如果想抛出
		OutOfMemoryError异常，不断创建新的线程，就可以引发这个异常。
		c).方法区和运行时常量池溢出：不断将字符加入常量池(利用String的intern()方法)，并用字符常量，防止Full GC 回收，
		就可引起OOM。产生大量的类去填满方法区就可引发方法区的OOM。
		d).直接内存溢出：利用DirectByteBuffer类，往里加。
		