一.判断当前引用是否存活的方法
	1.引用计数法：采用一个计数器计数，当有一个地方指向它时，计数器加一；
	  某一引用失效时，计数器减一，任何计数器值为0的对象，不可能再被使用
	  缺点：无法解决循环引用的问题
	
	2.可达性分析：从GC Root出发，发现某一对象不可到达时，则证明该对象不可引用（脑补一个树）
		可作为GC Root的对象
			a).虚拟机栈引用的对象
			b).方法区中类静态属性引用的对象
			c).方法区中常量引用的对象
			d).本地方法栈中JNI(Native)引用的方法
二.引用类型分类
	1.强引用（Strong Reference）：只要强引用存在，该对象就永远不会被回收，例如：Object obj = new Object();
	2.软引用（Soft Reference）：当将要发生内存溢出之前，将其作为二次回收的范围，只要第一次回收后，内存足够，
		就不会去回收它，如果第一次回收后，仍然会发生内存溢出，就会回收软引用的对象。
	3.弱引用（Weak Reference）：该对象只能存活到下一次垃圾收集发生之前
	4.虚引用（PhantomReference）:该引用的唯一目的是当这个对象被回收时，收到一个系统通知
三.finalize()运行原理：
	    当一个对象被标记为不可达时，不会被立即回收，而是会去判断该对象有没有必要执行finalize(),当对象没有覆盖
	或者finalize（）已经被虚拟机执行过，都视为"没有必要执行"。而执行finalize()的过称为：将该对象放入一个F-Queue
	的队列之中，然后GC会对F-Queue中的对象进行第二次标记，如果对象能够在这个过程中重新与引用链中的其他对象建立关联，
	那么第二次标记时就会将该对象移除队列，若仍然没有关联，则它真的就被回收了。
	    值得注意的是：这种自救的机会只有一次，因为finalize（）只会被执行一次。
四.永生代的回收
	回收对象：废弃常量，无用的类
	回收准则：废弃常量的判定很简单，也就是没有任何String对象引用这个常量，也没有其他地方引用，即可判定为废弃
			
			但无用的类的判定
				1.所有实例被回收
				2.ClassLoader被回收
				3.Class对象在所有地方都没被使用，且都没有通过该Class对象访问该类的方法
			以上准则只是说可以被回收，并不是像对象那样，没用就会被回收。
五.垃圾收集算法
	1.标记-清除：分为标记和清理两个步骤，标记也就是前面介绍finalize方法时那样
		
		不足：a).两个步骤的效率都不高
			  b).会产生内存碎片，导致分配大对象时，可能会提前触发GC。
	
	2.复制：将内存分为两块相等的区域，每次只使用一块，当这一块内存使用完后，会将活着的对象复制到另一块内存上，
			然后清理这一块的内存
		
		适用于：新生代垃圾收集，因为对象的成活率不高，所以每次复制的对象就很少，回收率高，效率快
		
		例如：目前的商业虚拟机，将新生代的收集分为 8:1:1的一个Eden区和两个Survivor区，每次使用一个Eden和一个Survivor
		回收时，将Eden区和当前Survivor区中存活的对象复制到另一个Survivor区，如果不够用，会向永久带申请借用内存(后有详解)，
		总之，只需浪费10%的空间就可以很好地满足新生代的收集工作。
	3.标记-整理：同样有标记的过程，但标记后，不是清理可回收对象，而是将存活对象向一端移动，然后清理掉边界外的内存。
		优点：对于存活率高的区域，不会产生大量的复制操作，并且不会产生内存碎片。
		
		适用于：永生代的垃圾收集，原因参优点。
	4.分代收集：一种思想
六.HotSpot的算法实现
	1.Stop The World:GC进行时停顿所有的的Java执行线程
	2.枚举根节点：简单地说就是对引用链上引用的对象进行检查，若采用硬扫描，就非常浪费资源。因此，HotSpot借助了OopMap
		这一数据结构来实现。
		
		OopMap：在类加载时HotSpot就会计算出对象的信息，并在JIT编译过程中，记录引用的位置，将这些信息存放在该数据结构中。
	3.安全点（Safepoint）：能否让程序有长时间执行特征的标准来选的（指令复用），例如方法调用，循环跳转，异常跳转
		方式：
			a).抢占式中断：不需要代码配合，当GC发生时，主动中断所有线程，若当前线程没有跑到Safepoint,就恢复线程，让它跑到安全点
			b).主动式中断：简单设置一个标识，线程主动去轮询这个标识，当标识为真时，就主动中断挂起（轮询标识和Safepint是重合的）
	4.安全区域（Safe Region）：是指在一段代码片段之中，引用关系不会发生变化，在这个区域的任何地方开始GC都是安全的
七.垃圾收集器
	1.新生代：
		a).Serial收集器：单线程，采用复制算法，在垃圾收集时，必须Stop The World；正因为如此，所以它简单高效，
		特别适合运行在Client模式下的虚拟机。
		
		b).ParNer收集器:并行,Serial的多线程版本，仍采用复制算法，垃圾收集时，同样需要Stop The World,适用于运行在
		Service模式下的虚拟机。
		
		c).Parallel Scavenge收集器：并行，多线程，采用自适应的策略，关注吞吐量，主要适用于后台线程，交互少。
			内含PS MarkSweep收集器，与Serial Old收集器类似
			
			主要参数：最大停顿时间，吞吐量设置
		
	2.老年代:
		a).Serial Old收集器:单线程，采用标记-整理算法，是CMS的后备方案
		b).Parallal Old收集器:并行，多线程，采用标记-整理算法
		c).CMS收集器:并发，标记-清除算法,注重交互，产生Concurrent Mode Failure时启用备选方案
			分为四个步骤：
				初始标记->并发标记->重新标记->并发清除
			特点：在初始标记，重新标记仍需要Stop The World，对CPU敏感，无法处理浮动垃圾(在并发清理阶段产生的垃圾)
			内存碎片的问题
	3.G1收集器：并发与并行，分代收集，空间整合，可预测的停顿
		思想：将Java堆分为若干个Region，G1跟踪每个Region的价值大小，优先回收空间价值大的Region
		初始标记->并发标记->最终标记->筛选回收
	4.GC日志
八.内存分配与回收策略
	1.对象优先在Eden分配,空间不足，发起Minor GC
	2.Full GC(Major GC)/Minor GC:前者是对老年代的GC，后者是对新生代的GC
	3.大对象直接进入老年代：避免在survivor和Eden之间来回复制
	4.长期存活的对象将进入老年代：默认15岁
	5.动态年龄判断：当suivivor区中相同年龄的所有对象大小总和大于survivor区的一半，
				则以后年龄大于该年龄的对象直接进入老年代
		
